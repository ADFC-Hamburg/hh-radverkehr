<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Radverkehrsdaten Hamburg</title>
    <link rel="stylesheet" href="lib/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin=""/>
    <script src="lib/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
    <style>
    body {
        padding: 0;
        margin: 0;
    }
    html, body, #map {
        height: 100%;
    }
    #loadingHint {
        position:absolute;
        top:50%;
        left:50%;
        transform:translate(-50%, -50%);
        color: white; background: #666666; opacity: .8;
        padding: 10px;
        z-index: 1000;
    }
    .leaflet-layer {
        filter: grayscale(0.8);
    }
    </style>
</head>
<body>
    <div id="map"> </div>

    <div id="loadingHint">Daten werden geladen...</div>

    <script>

    // Karteneinstellungen
    var tileUrl = 'http://a.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png ';
    var attribution = `
        Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a><br/>
        <b>Radverkehrsmengen (DB Rad+):</b> 
            <a href="https://metaver.de/trefferanzeige?docuuid=0CFF2923-AAEC-42FE-8DE8-A2C56A3EA1CF">Behörde für Verkehr und Mobilitätswende (BVM)</a> (Lizenz: <a href="https://www.govdata.de/dl-de/by-2-0" target="blank">dl-de/by-2-0</a>)<br/>
        <b>Velorouten:</b>
            <a href="https://metaver.de/trefferanzeige?docuuid=8254E244-7DD3-401D-AA15-4CDE78D4E91F">Behörde für Verkehr und Mobilitätswende (BVM)</a> (Lizenz: <a href="https://www.govdata.de/dl-de/by-2-0" target="blank">dl-de/by-2-0</a>)
        `;

    var map = L.map('map').setView([53.54, 10], 13);
    L.tileLayer(tileUrl, {
        attribution: attribution,
        maxZoom: 18
    }).addTo(map);

    // Konfigurationen der Daten und Schwellwerte
    const config = {
        urls: {
           data2022: "data/dbrad_jahr_2022.json.min",
           data2023: "data/dbrad_jahr_2023.json",
           data_letzte_woche: "data/dbrad_letzte_woche.json",
           velorouten: [
            "data/velorouten/veloroute1.json",
            "data/velorouten/veloroute2.json",
            "data/velorouten/veloroute3.json",
            "data/velorouten/veloroute4.json",
            "data/velorouten/veloroute5.json",
            "data/velorouten/veloroute6.json",
            "data/velorouten/veloroute7.json",
            "data/velorouten/veloroute8.json",
            "data/velorouten/veloroute9.json",
            "data/velorouten/veloroute10.json",
            "data/velorouten/veloroute11.json",
            "data/velorouten/veloroute12.json",
            "data/velorouten/veloroute13.json",
            "data/velorouten/veloroute14.json",
            "data/velorouten/veloroute-verb.json",
           ]
           
        }
    };

    // Weight = Dicke der Streckendarstellung
    // 2 Möglichkeiten, die noch nicht einheitlich benutzt werden

    // Entweder automatische Gewichtung der Streckenabschnitte, indem man auf die Anzahl der Fahrten pro Tag im Messzeitraum runterrechnet
    const anzahlProTagToWeight = (anzahl, tage) => {
        return anzahl / tage;
    };

    // Oder für jeden Datensatz händisch die Schwellwerte festlegen:
    const anzahlToWeight2023 = (anzahl) => {
        if (anzahl > 90) {
            return 6;
        } else if (anzahl > 75) {
            return 5;
        } else if (anzahl > 60) {
            return 4;
        } else if (anzahl > 45) {
            return 4;
        } else if (anzahl > 30) {
            return 3;
        } else if (anzahl > 15) {
            return 2;
        } else {
            return 2; // minimalwert in den daten: 8
        }
    };

    const anzahlToWeight2022 = (anzahl) => {
        if (anzahl > 3000) {
            return 6;
        } else if (anzahl > 2500) {
            return 5;
        } else if (anzahl > 2000) {
            return 4;
        } else if (anzahl > 1500) {
            return 4;
        } else if (anzahl > 1000) {
            return 3;
        } else if (anzahl > 500) {
            return 2;
        } else {
            return 1;
        }
    };


    // Farbe je nach gemessener Durchschnittsgeschwindigkeit
    const colorFromSpeed = (speed) => {
        if (speed < 10) {
            return "red";
        } else if (speed < 12) {
            return "red";
        } else if (speed < 18) {
            return "orange";
        } else if (speed < 21) {
            return "yellow";
        } else if (speed < 30) {
            return "green";
        }
        return "black"; // there should be no records of speed >= 30
    };

    const fetchJson = (url) => fetch(url).then(resp => resp.json()).catch(e => console.log(`url: ${url}; error: ${e}`));

    // Hervorhebung von Streckenabschnitten, indem ein zweiter Layer darunter eingeblendet wird
    const getLayerWithOutline = (geoJson, optionsOutline, optionsFill) => {
        return [L.geoJSON(geoJson, optionsOutline), L.geoJSON(geoJson, optionsFill)];
    };

    const filterFeatureNachKoordinaten = (koordinaten) => {
        return f => JSON.stringify(f.geometry.coordinates) == JSON.stringify(koordinaten)
    };

    const zeichneLayer = (daten, getFarbe, getDicke, overlayOptionen) => {
        if (overlayOptionen.active) {
            return [   L.geoJSON(daten, {style: (feature) => ({
                    color: "black",
                    weight: getDicke() + 1,
                    opacity: overlayOptionen.dicke(feature)
                })}),
                L.geoJSON(daten, {style: (feature) => ({
                    color: getFarbe(),
                    weight: getDicke(),
                    opacity: 1
                }), onEachFeature: (feature, layer) => {
                    layer.bindPopup("Lade.... ").on("popupopen", (event) => { // Lade Content erst beim Klick, sonst werden alle Popupinhalte beim Laden der Seite erzeugt!
                        event.popup.setContent(geschwindigkeitenFuerAbschnitt(feature));
                    });
                }
            })]
        } else {
            return [ L.geoJSON(daten, {style: (feature) => ({
                color: getFarbe(),
                weight: getDicke(),
                opacity: 1
            }), onEachFeature: (feature, layer) => {
                layer.bindPopup("Lade.... ").on("popupopen", (event) => { // Lade Content erst beim Klick, sonst werden alle Popupinhalte beim Laden der Seite erzeugt!
                    event.popup.setContent(geschwindigkeitenFuerAbschnitt(feature));
                });
            }
        })]
        }
    };


    // Hier ist der eigentliche Ablauf der Seite als asynchrone Funktion, um Oberfläche nicht zu blockieren
    const start = async () => {
        // erstmal alle Daten holen - kann man auch parallelisieren => spätere Optimierung, etwas weniger warten am Anfang
        const data2022 = await fetchJson(config.urls.data2022);
        const data2023 = await fetchJson(config.urls.data2023);
        const data_letzte_woche = await fetchJson(config.urls.data_letzte_woche);

        const geschwindigkeitenFuerAbschnitt = (feature) => {
            // hole Daten basierend auf Koordinaten für aktuellen Abschnitt
            const featureFrom2022 = data2022.features.filter(filterFeatureNachKoordinaten(feature.geometry.coordinates))[0];
            const featureFrom2023 = data2023.features.filter(filterFeatureNachKoordinaten(feature.geometry.coordinates))[0];
            const featureFromLetzteWoche = data_letzte_woche.features.filter(filterFeatureNachKoordinaten(feature.geometry.coordinates))[0];

            const v2022 = featureFrom2022?.properties.geschwindigkeit ?? "-";
            const v2023 = featureFrom2023?.properties.geschwindigkeit ?? "-";
            const vLetzteWoche = featureFromLetzteWoche?.properties.geschwindigkeit ?? "-";

            return `Gemessene Durchschnittsgeschwindigkeiten für diesen Abschnitt in km/h:<br />
            <b>2022:</b> ${v2022} 
                (basierend auf ${featureFrom2022?.properties.anzahl ?? "-"} Fahrten)<br />
            <b>2023 bisher:</b> ${v2023}
                (basierend auf ${featureFrom2023?.properties.anzahl ?? "-"} Fahrten)<br />
            <b>Letzte Woche:</b> ${vLetzteWoche}
                (basierend auf ${featureFromLetzteWoche?.properties.anzahl ?? "-"} Fahrten)`;
        };


        const dbrad2023 = getLayerWithOutline(data2023, {style: (feature) => ({
                color: "black",
                weight: anzahlToWeight2023(feature.properties.anzahl, 30) + 1,
                opacity: feature.properties.anzahl > 45 ? 1 : 0
            })},
            {style: (feature) => ({
                color: colorFromSpeed(feature.properties.geschwindigkeit),
                weight: anzahlToWeight2023(feature.properties.anzahl, 30),
                opacity: 1
            }), onEachFeature: (feature, layer) => {
                layer.bindPopup("Lade.... ").on("popupopen", (event) => { // Lade Content erst beim Klick, sonst werden alle Popupinhalte beim Laden der Seite erzeugt!
                    event.popup.setContent(geschwindigkeitenFuerAbschnitt(feature));
                });
            }
        });


        const dbrad2022 = getLayerWithOutline(data2022,
            {style: (feature) => ({
                color: "black",
                weight: anzahlToWeight2022(feature.properties.anzahl, 365) + 1,
                opacity: feature.properties.anzahl > 2000 ? 1 : 0
            })},
            {style: (feature) => ({
                color: colorFromSpeed(feature.properties.geschwindigkeit),
                weight: anzahlToWeight2022(feature.properties.anzahl, 365),
                opacity: feature.properties.anzahl > 100 ? 1 : 0
            }), onEachFeature: (feature, layer) => {
                layer.bindPopup("Lade.... ").on("popupopen", (event) => { // Lade Content erst beim Klick, sonst werden alle Popupinhalte beim Laden der Seite erzeugt!
                    event.popup.setContent(geschwindigkeitenFuerAbschnitt(feature));
                });
            }});

        const letzte_woche = L.geoJSON(data_letzte_woche, {style: (feature) => ({
                color: colorFromSpeed(feature.properties.geschwindigkeit),
                weight: anzahlProTagToWeight(feature.properties.anzahl, 7),
                opacity: 1
            }), onEachFeature: (feature, layer) => {
                layer.bindPopup("Lade.... ").on("popupopen", (event) => { // Lade Content erst beim Klick, sonst werden alle Popupinhalte beim Laden der Seite erzeugt!
                    event.popup.setContent(geschwindigkeitenFuerAbschnitt(feature));
                });
            }});

        
        // wird später nachgeladen
        const velogruppe = L.featureGroup([]);

        L.control.layers({
            "Radverkehrsdaten 2022": L.featureGroup(dbrad2022),
            "Radverkehrsdaten 2023": L.featureGroup(dbrad2023).addTo(map),
            "Radverkehrsdaten Letzte Woche": L.featureGroup([letzte_woche]),
        }, {
            "Velorouten": velogruppe.bringToBack()
        }, {collapsed: false}).addTo(map);

        document.getElementById("loadingHint").style.display = "none";


        // Nachladen der Velorouten
        const velorouten_data = await Promise.all(config.urls.velorouten.map(url => fetchJson(url)));
        const velorouten = velorouten_data.map(veloroute => {
            return L.geoJSON(veloroute, {style: (feature) => ({
                color: "blue",
                weight: 8,
                opacity: 0.3
            })});
        });
        velorouten.forEach(veloroute => velogruppe.addLayer(veloroute));        
    };

    start();

</script>

</body>
</html>
