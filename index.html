<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="lib/leaflet.css"
   integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
   crossorigin=""/>
 <script src="lib/leaflet.js"
 integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
 crossorigin=""></script>
    <style>
    body {
        padding: 0;
        margin: 0;
    }
    html, body, #map {
        height: 100%;
    }
    #loadingHint {
        position:absolute;
        top:50%;
        left:50%;
        transform:translate(-50%, -50%);
        color: white; background: #666666; opacity: .8;
        padding: 10px;
        z-index: 1000;
    }
    .leaflet-layer {
        filter: grayscale(0.8);
    }
    </style>
</head>
<body>
    <div id="map"> </div>

    <div id="loadingHint">Daten werden geladen...</div>

    <script>
    var tileUrl = 'http://a.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png ';
    var tileAttribution = 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>';


    var map = L.map('map').setView([53.54, 10], 12);
    L.tileLayer(tileUrl, {
        attribution: tileAttribution,
        maxZoom: 18
    }).addTo(map);

    const fetchJson = (url) => fetch(url).then(resp => resp.json()).catch(e => console.log(`url: ${url}; error: ${e}`));

    const anzahlToWeight2023 = (anzahl) => {
        if (anzahl > 90) {
            return 6;
        } else if (anzahl > 75) {
            return 5;
        } else if (anzahl > 60) {
            return 4;
        } else if (anzahl > 45) {
            return 4;
        } else if (anzahl > 30) {
            return 3;
        } else if (anzahl > 15) {
            return 2;
        } else {
            return 1; // minimalwert in den daten: 8
        }
    }

    const anzahlToWeight2022 = (anzahl) => {
        if (anzahl > 3000) {
            return 6;
        } else if (anzahl > 2500) {
            return 5;
        } else if (anzahl > 2000) {
            return 4;
        } else if (anzahl > 1500) {
            return 4;
        } else if (anzahl > 1000) {
            return 3;
        } else if (anzahl > 500) {
            return 2;
        } else {
            return 1;
        }
    }

    const colorFromSpeed = (speed) => {
        if (speed < 10) {
            return "red";
        } else if (speed < 12) {
            return "red";
        } else if (speed < 18) {
            return "orange";
        } else if (speed < 21) {
            return "yellow";
        } else if (speed < 30) {
            return "green";
        }
        return "black"; // there should be no records of speed >= 30
    }

    const fetchLayerWithOutline = async (url, optionsOutline, optionsFill) => {
        const geoJson = await fetchJson(url);
        return [L.geoJSON(geoJson, optionsOutline), L.geoJSON(geoJson, optionsFill)];
    };

    const dbrad2023 = fetchLayerWithOutline("data/dbrad_jahr_2023.json",
        {style: (feature) => ({
            color: "black",
            weight: anzahlToWeight2023(feature.properties.anzahl) + 1,
            opacity: feature.properties.anzahl > 45 ? 1 : 0
        })},
        {style: (feature) => ({
            color: colorFromSpeed(feature.properties.geschwindigkeit),
            weight: anzahlToWeight2023(feature.properties.anzahl),
            opacity: 1
        })});

    const dbrad2022 = fetchLayerWithOutline("data/dbrad_jahr_2022.json.min",
        {style: (feature) => ({
            color: "black",
            weight: anzahlToWeight2022(feature.properties.anzahl) + 1,
            opacity: feature.properties.anzahl > 2000 ? 1 : 0
        })},
        {style: (feature) => ({
            color: colorFromSpeed(feature.properties.geschwindigkeit),
            weight: anzahlToWeight2022(feature.properties.anzahl),
            opacity: feature.properties.anzahl > 100 ? 1 : 0
        })});

    const fetchLayers = async () => {
        const letzte_woche = L.geoJSON(await fetchJson("data/dbrad_woche_2023-01-31.json"), {style: (feature) => ({
            color: colorFromSpeed(feature.properties.geschwindigkeit),
            weight: anzahlToWeight2023(feature.properties.anzahl),
            opacity: 1
        })});

        L.control.layers({
            "2022": L.featureGroup(await dbrad2022).bringToFront(),
            "2023": L.featureGroup(await dbrad2023).bringToFront().addTo(map),
            "Letzte Woche": L.featureGroup([letzte_woche]).bringToFront(),
        }, null, {collapsed: false}).addTo(map);

        document.getElementById("loadingHint").style.display = "none";
    }
    fetchLayers();

</script>

</body>
</html>
